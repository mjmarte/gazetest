<!DOCTYPE html>
<html>
    <head>
        <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
        <title>WebGazer Calibration</title>
        <style>
            body {
                margin: 0;
                padding: 0;
                overflow: hidden;
            }

            #plotting_canvas {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 1;
            }

            /* Video feed styling */
            #webgazerVideoContainer {
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
                width: 320px !important;
                height: 240px !important;
                z-index: 2 !important;
            }

            /* Calibration points */
            .Calibration {
                width: 20px;
                height: 20px;
                background-color: red;
                border: none;
                border-radius: 50%;
                position: fixed;
                z-index: 999999;
                cursor: pointer;
                pointer-events: auto;
            }

            .Calibration:hover {
                background-color: blue;
            }

            /* Point positions */
            #Pt1 { top: 20px; left: 340px; }
            #Pt2 { top: 20px; left: 50%; transform: translateX(-50%); }
            #Pt3 { top: 20px; right: 20px; }
            #Pt4 { top: 50%; left: 340px; transform: translateY(-50%); }
            #Pt5 { top: 50%; left: 50%; transform: translate(-50%, -50%); }
            #Pt6 { top: 50%; right: 20px; transform: translateY(-50%); }
            #Pt7 { bottom: 20px; left: 340px; }
            #Pt8 { bottom: 20px; left: 50%; transform: translateX(-50%); }
            #Pt9 { bottom: 20px; right: 20px; }

            /* Status text */
            #status {
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(255, 255, 255, 0.9);
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                z-index: 3;
                text-align: center;
            }

            /* Recording controls */
            #recording-controls {
                position: fixed;
                bottom: 20px;
                left: 20px;
                background: rgba(255, 255, 255, 0.9);
                padding: 15px;
                border-radius: 5px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                z-index: 3;
            }

            #recording-controls button {
                margin: 5px;
                padding: 8px 16px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
            }

            #start-recording {
                background-color: #28a745;
                color: white;
            }

            #stop-recording {
                background-color: #dc3545;
                color: white;
            }

            /* Gaze coordinates */
            #gaze {
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(255, 255, 255, 0.9);
                padding: 10px;
                border-radius: 5px;
                box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                z-index: 3;
            }

            /* Ensure calibration points container is on top */
            .calibrationDiv {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                z-index: 999999;
                pointer-events: none;
            }
        </style>
    </head>
    <body>
        <canvas id="plotting_canvas" width="500" height="500"></canvas>

        <!-- Calibration points -->
        <div class="calibrationDiv">
            <input type="button" class="Calibration" id="Pt1">
            <input type="button" class="Calibration" id="Pt2">
            <input type="button" class="Calibration" id="Pt3">
            <input type="button" class="Calibration" id="Pt4">
            <input type="button" class="Calibration" id="Pt5">
            <input type="button" class="Calibration" id="Pt6">
            <input type="button" class="Calibration" id="Pt7">
            <input type="button" class="Calibration" id="Pt8">
            <input type="button" class="Calibration" id="Pt9">
        </div>

        <!-- Status text -->
        <div id="status">
            <p>Click on each point 5 times to calibrate.</p>
        </div>

        <!-- Gaze coordinates -->
        <div id="gaze">
            <p>X: <span id="gaze-x">0</span></p>
            <p>Y: <span id="gaze-y">0</span></p>
        </div>

        <!-- Recording controls -->
        <div id="recording-controls" style="display: none;">
            <button id="start-recording">Start Recording</button>
            <button id="stop-recording" style="display: none;">Stop Recording</button>
            <p>Session: <span id="session-id">None</span></p>
            <p>Recording Time: <span id="recording-time">00:00</span></p>
        </div>

        <script src="webgazer.js"></script>
        <script>
            window.onload = async function() {
                var width = 320;
                var height = 240;
                var topDist = '0px';
                var leftDist = '0px';
                
                // Store click coordinates for accuracy test
                var xPast50 = new Array(50);
                var yPast50 = new Array(50);
                var clickedPoints = {};
                
                // Wait for WebGazer to fully initialize
                function wait(ms) {
                    return new Promise(resolve => setTimeout(resolve, ms));
                }

                // Initialize webgazer
                await webgazer.setRegression('ridge')
                    .setTracker('TFFacemesh')
                    .begin();
                
                // Wait for WebGazer to stabilize
                await wait(2500);
                
                webgazer.showVideoPreview(true)
                    .showPredictionPoints(true)
                    .applyKalmanFilter(true);

                // Set up video feed positioning
                var setup = function() {
                    var video = document.getElementById('webgazerVideoFeed');
                    video.style.display = 'block';
                    video.style.position = 'fixed';
                    video.style.top = topDist;
                    video.style.left = leftDist;
                    video.style.width = width + 'px';
                    video.style.height = height + 'px';
                    video.style.transform = 'scaleX(-1)';
                };

                setup();

                // Add gaze data collector
                webgazer.setGazeListener(function(data, timestamp) {
                    if (data == null || data.x == null || data.y == null) return;
                    
                    // Store last 50 predictions for accuracy calculation
                    xPast50.push(data.x);
                    yPast50.push(data.y);
                    if (xPast50.length > 50) {
                        xPast50.shift();
                        yPast50.shift();
                    }
                    
                    // Update gaze point display
                    document.getElementById('gaze-x').textContent = Math.round(data.x);
                    document.getElementById('gaze-y').textContent = Math.round(data.y);
                });

                // Calibration functionality
                var PointCalibrate = 0;
                var CalibrationPoints = {};
                
                // Calculate point position
                function calculatePointPosition(element) {
                    const rect = element.getBoundingClientRect();
                    return {
                        x: rect.left + rect.width / 2,
                        y: rect.top + rect.height / 2
                    };
                }

                // Calculate accuracy
                function calculateAccuracy() {
                    var windowHeight = window.innerHeight;
                    var windowWidth = window.innerWidth;
                    var accuracies = [];
                    
                    for (let pointId in clickedPoints) {
                        const point = clickedPoints[pointId];
                        
                        // Calculate distance between prediction and actual point
                        const xDiff = point.x - point.predX;
                        const yDiff = point.y - point.predY;
                        const distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
                        
                        // Calculate precision percentage using window height as reference
                        const halfWindowHeight = windowHeight / 2;
                        let precision = 0;
                        if (distance <= halfWindowHeight && distance > -1) {
                            precision = 100 - (distance / halfWindowHeight * 100);
                        } else if (distance > halfWindowHeight) {
                            precision = 0;
                        } else if (distance > -1) {
                            precision = 100;
                        }
                        
                        accuracies.push(precision);
                    }
                    
                    // Calculate average accuracy
                    const avgAccuracy = accuracies.reduce((sum, val) => sum + val, 0) / accuracies.length;
                    return Math.round(avgAccuracy);
                }

                // Show calibration validation point
                function showValidationPoint() {
                    const validationPoint = document.createElement('div');
                    validationPoint.style.position = 'fixed';
                    validationPoint.style.left = '50%';
                    validationPoint.style.top = '50%';
                    validationPoint.style.transform = 'translate(-50%, -50%)';
                    validationPoint.style.width = '20px';
                    validationPoint.style.height = '20px';
                    validationPoint.style.backgroundColor = 'red';
                    validationPoint.style.borderRadius = '50%';
                    validationPoint.style.zIndex = '999999';
                    validationPoint.id = 'validationPoint';
                    document.body.appendChild(validationPoint);

                    // Store predictions for 5 seconds
                    const predictions = [];
                    const startTime = performance.now();
                    const collectData = setInterval(() => {
                        const prediction = webgazer.getCurrentPrediction();
                        if (prediction && prediction.x !== null && prediction.y !== null) {
                            predictions.push({
                                x: prediction.x,
                                y: prediction.y
                            });
                        }
                    }, 50);  // Collect at 20Hz

                    // After 5 seconds, calculate validation accuracy
                    setTimeout(() => {
                        clearInterval(collectData);
                        document.body.removeChild(validationPoint);
                        
                        if (predictions.length === 0) {
                            alert('No gaze data collected during validation. Please try calibrating again.');
                            return;
                        }

                        // Calculate average prediction
                        const avgPred = predictions.reduce((acc, curr) => ({
                            x: acc.x + curr.x / predictions.length,
                            y: acc.y + curr.y / predictions.length
                        }), { x: 0, y: 0 });

                        // Calculate distance to center
                        const centerX = window.innerWidth / 2;
                        const centerY = window.innerHeight / 2;
                        const xDiff = centerX - avgPred.x;
                        const yDiff = centerY - avgPred.y;
                        const distance = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));
                        
                        // Calculate validation accuracy
                        const halfWindowHeight = window.innerHeight / 2;
                        let validationAccuracy = 0;
                        if (distance <= halfWindowHeight && distance > -1) {
                            validationAccuracy = 100 - (distance / halfWindowHeight * 100);
                        }
                        
                        document.getElementById('status').innerHTML += 
                            `<p>Validation Accuracy: ${Math.round(validationAccuracy)}%</p>`;
                        
                        // Show recording controls
                        document.getElementById('recording-controls').style.display = 'block';
                    }, 5000);
                }
                
                // Add click handlers to calibration points
                document.querySelectorAll('.Calibration').forEach(function(el) {
                    el.addEventListener('click', function(event) {
                        var id = event.target.id;
                        
                        if (!CalibrationPoints[id]) {
                            CalibrationPoints[id] = 0;
                        }
                        CalibrationPoints[id]++;
                        
                        // Store point position and current prediction
                        const pos = calculatePointPosition(event.target);
                        if (!clickedPoints[id]) {
                            clickedPoints[id] = {
                                x: pos.x,
                                y: pos.y,
                                predX: xPast50.reduce((a, b) => a + b, 0) / xPast50.length,
                                predY: yPast50.reduce((a, b) => a + b, 0) / yPast50.length
                            };
                        }
                        
                        if (CalibrationPoints[id] == 5) {
                            event.target.style.backgroundColor = 'green';
                            PointCalibrate++;
                        } else if (CalibrationPoints[id] < 5) {
                            event.target.style.backgroundColor = 'yellow';
                        }
                        
                        if (PointCalibrate >= 9) {
                            // Calculate initial accuracy
                            const accuracy = calculateAccuracy();
                            document.getElementById('status').innerHTML = 
                                `<p>Initial calibration complete!</p>
                                <p>Accuracy: ${accuracy}%</p>
                                <p>Please stare at the red dot in the center for 5 seconds for validation...</p>`;
                            
                            // Hide calibration points during validation
                            document.querySelector('.calibrationDiv').style.display = 'none';
                            
                            // Show validation point
                            showValidationPoint();
                        }
                    });
                });
                
                // Recording functionality
                let isRecording = false;
                let recordingStartTime = null;
                let gazeData = [];
                let recordingInterval = null;
                let frameRequestId = null;

                window.startRecording = function() {
                    if (isRecording) return;
                    
                    isRecording = true;
                    recordingStartTime = performance.now();
                    gazeData = [];
                    
                    document.getElementById('start-recording').style.display = 'none';
                    document.getElementById('stop-recording').style.removeProperty('display');
                    document.getElementById('session-id').textContent = new Date().toISOString();
                    
                    recordingInterval = setInterval(updateRecordingTime, 1000);
                    requestAnimationFrame(recordGazeData);
                };

                function recordGazeData(timestamp) {
                    if (!isRecording) return;
                    
                    const prediction = webgazer.getCurrentPrediction();
                    if (prediction && prediction.x !== null && prediction.y !== null) {
                        gazeData.push({
                            timestamp: performance.now(),
                            x: prediction.x,
                            y: prediction.y,
                            elapsedTime: performance.now() - recordingStartTime
                        });
                    }
                    
                    frameRequestId = requestAnimationFrame(recordGazeData);
                }

                function updateRecordingTime() {
                    const elapsed = Date.now() - recordingStartTime;
                    const minutes = Math.floor(elapsed / 60000);
                    const seconds = Math.floor((elapsed % 60000) / 1000);
                    document.getElementById('recording-time').textContent = 
                        `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                }

                window.stopRecording = function() {
                    if (!isRecording) return;
                    
                    isRecording = false;
                    clearInterval(recordingInterval);
                    cancelAnimationFrame(frameRequestId);
                    
                    document.getElementById('stop-recording').style.display = 'none';
                    document.getElementById('start-recording').style.removeProperty('display');
                    
                    // Only save if we have valid data
                    if (gazeData.length > 0) {
                        const duration = (gazeData[gazeData.length - 1].timestamp - gazeData[0].timestamp) / 1000;
                        const samplingRate = gazeData.length / duration;
                        console.log(`Recording finished. Average sampling rate: ${samplingRate.toFixed(2)} Hz`);
                        
                        const csvContent = "data:text/csv;charset=utf-8," + 
                            "timestamp,x,y,elapsedTime\n" +
                            gazeData.map(row => 
                                `${row.timestamp},${row.x},${row.y},${row.elapsedTime}`
                            ).join("\n");
                        
                        const encodedUri = encodeURI(csvContent);
                        const link = document.createElement("a");
                        link.setAttribute("href", encodedUri);
                        link.setAttribute("download", `gaze_data_${new Date().toISOString()}.csv`);
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                    } else {
                        console.log("No valid gaze data recorded");
                    }
                };

                // Add event listeners
                document.getElementById('start-recording').addEventListener('click', window.startRecording);
                document.getElementById('stop-recording').addEventListener('click', window.stopRecording);
            };

            window.onbeforeunload = function() {
                webgazer.end();
            }
        </script>
    </body>
</html>
